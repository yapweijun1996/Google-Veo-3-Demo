"use strict";
/**
 * @license
 * Copyright Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CssSanitizerBuilder = exports.HtmlSanitizerBuilder = exports.BaseSanitizerBuilder = void 0;
const secrets_js_1 = require("../../internals/secrets.js");
const allowlists_js_1 = require("./css/allowlists.js");
const sanitizer_js_1 = require("./css/sanitizer.js");
const html_sanitizer_js_1 = require("./html_sanitizer.js");
const default_sanitizer_table_js_1 = require("./sanitizer_table/default_sanitizer_table.js");
const sanitizer_table_js_1 = require("./sanitizer_table/sanitizer_table.js");
/**
 * The base class for all sanitizer builders.
 */
class BaseSanitizerBuilder {
    constructor() {
        // To denote if the builder has called build() and therefore should make no
        // further changes to the sanitizer table.
        this.calledBuild = false;
        this.sanitizerTable = default_sanitizer_table_js_1.DEFAULT_SANITIZER_TABLE;
    }
    /** Builder option to restrict allowed elements to a smaller subset. */
    onlyAllowElements(elementSet) {
        const allowedElements = new Set();
        const allowedElementPolicies = new Map();
        for (let element of elementSet) {
            element = element.toUpperCase();
            if (!this.sanitizerTable.isAllowedElement(element)) {
                throw new Error(`Element: ${element}, is not allowed by html5_contract.textpb`);
            }
            const elementPolicy = this.sanitizerTable.elementPolicies.get(element);
            if (elementPolicy !== undefined) {
                allowedElementPolicies.set(element, elementPolicy);
            }
            else {
                allowedElements.add(element);
            }
        }
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(allowedElements, allowedElementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Builder option to allow a set of custom elements. Must be called either
     * without or after `onlyAllowElements` - will be overwritten otherwise.
     * Custom elements must contain a dash.
     */
    allowCustomElement(element, allowedAttributes) {
        const allowedElements = new Set(this.sanitizerTable.allowedElements);
        const allowedElementPolicies = new Map(this.sanitizerTable.elementPolicies);
        element = element.toUpperCase();
        if (!(0, sanitizer_table_js_1.isCustomElement)(element)) {
            throw new Error(`Element: ${element} is not a custom element`);
        }
        if (allowedAttributes) {
            const elementPolicy = new Map();
            for (const attribute of allowedAttributes) {
                elementPolicy.set(attribute.toLowerCase(), {
                    policyAction: sanitizer_table_js_1.AttributePolicyAction.KEEP,
                });
            }
            allowedElementPolicies.set(element, elementPolicy);
        }
        else {
            allowedElements.add(element);
        }
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(allowedElements, allowedElementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Builder option to restrict allowed attributes to a smaller subset.
     *
     * If the attribute isn't currently allowed then it won't be added.
     */
    onlyAllowAttributes(attributeSet) {
        const allowedGlobalAttributes = new Set();
        const globalAttributePolicies = new Map();
        const elementPolicies = new Map();
        for (const attribute of attributeSet) {
            if (this.sanitizerTable.allowedGlobalAttributes.has(attribute)) {
                allowedGlobalAttributes.add(attribute);
            }
            if (this.sanitizerTable.globalAttributePolicies.has(attribute)) {
                globalAttributePolicies.set(attribute, this.sanitizerTable.globalAttributePolicies.get(attribute));
            }
        }
        for (const [elementName, originalElementPolicy,] of this.sanitizerTable.elementPolicies.entries()) {
            const newElementPolicy = new Map();
            for (const [attribute, attributePolicy,] of originalElementPolicy.entries()) {
                if (attributeSet.has(attribute)) {
                    newElementPolicy.set(attribute, attributePolicy);
                }
            }
            elementPolicies.set(elementName, newElementPolicy);
        }
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, elementPolicies, allowedGlobalAttributes, globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Allows all or a definite set of data attributes passed.
     *
     * When called without arguments, all data attributes are allowed.
     * When a set of attributes is passed, its values must be prefixed with "data-"
     *
     * If called with onlyAllowElements or onlyAllowAttributes, those methods must
     * be called first.
     */
    allowDataAttributes(attributes) {
        if (attributes === undefined) {
            const globallyAllowedAttributePrefixes = new Set(this.sanitizerTable.globallyAllowedAttributePrefixes);
            globallyAllowedAttributePrefixes.add('data-');
            this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, globallyAllowedAttributePrefixes);
            return this;
        }
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        for (const attribute of attributes) {
            if (attribute.indexOf('data-') !== 0) {
                throw new Error(`data attribute: ${attribute} does not begin with the prefix "data-"`);
            }
            allowedGlobalAttributes.add(attribute);
        }
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Preserves style attributes. Note that the sanitizer won't parse and
     * sanitize the values but keep them as they are. In particular this means
     * that the code will be able to call functions that could do undesirable
     * things (e.g. `url` to trigger a network request), as well as any custom
     * properties or functions defined by the application.
     */
    allowStyleAttributes() {
        const globalAttributePolicies = new Map(this.sanitizerTable.globalAttributePolicies);
        globalAttributePolicies.set('style', {
            policyAction: sanitizer_table_js_1.AttributePolicyAction.KEEP_AND_SANITIZE_STYLE,
        });
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, this.sanitizerTable.allowedGlobalAttributes, globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Preserves the class attribute on all elements. This means contents can
     * adopt CSS styles from other page elements and possibly mask themselves as
     * legitimate UI elements, which can lead to phishing.
     */
    allowClassAttributes() {
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        allowedGlobalAttributes.add('class');
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Preserves id attributes. This carries moderate risk as it allows an
     * element to override other elements with the same ID.
     */
    allowIdAttributes() {
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        allowedGlobalAttributes.add('id');
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Preserves (some) attributes that reference existing ids. This carries a
     * moderate security risk, because sanitized content can create semantic
     * associations with existing elements in the page, regardless of the layout.
     * This could be used to override the label associated with a form input by a
     * screen reader, and facilitate phishing.
     */
    allowIdReferenceAttributes() {
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        allowedGlobalAttributes
            .add('aria-activedescendant')
            .add('aria-controls')
            .add('aria-labelledby')
            .add('aria-owns')
            .add('for')
            .add('list');
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
        return this;
    }
    /**
     * Sets the ResourceUrlPolicy to be used by the sanitizer.
     *
     * The ResourceUrlPolicy can be used to decide whether a given URL is allowed
     * to be loaded as an external resource. It is a function that an instance
     * of `URL` and a set of hints giving a context on why an image was loaded.
     *
     * The policy can return `null` to indicate that the resource should be
     * dropped, otherwise it should return a valid `URL` that will be used to
     * replace the original URL in the sanitized output.
     *
     * For example the following policy drops all images loaded from
     * `https://forbidden.google.com` but allows all other images.
     *
     * ```typescript
     * const resourceUrlPolicy: ResourceUrlPolicy = (url) => {
     *   if (url.origin === 'https://forbidden.google.com') {
     *     return null;
     *   }
     *   return url;
     * };
     * ```
     *
     * You can also use the `ResourceUrlPolicyHints` to make the policy more
     * informed. For example the following policy only allows images loaded
     * via an <img src> element but drops all other images.
     *
     * ```typescript
     * const resourceUrlPolicy: ResourceUrlPolicy = (url, hints) => {
     *   if (hints.type === ResourceUrlPolicyHintsType.HTML_ATTRIBUTE &&
     *       hints.attributeName === 'src' &&
     *       hints.elementName === 'IMG') {
     *     return url;
     *   }
     *   return null;
     * };
     * ```
     */
    withResourceUrlPolicy(resourceUrlPolicy) {
        this.resourceUrlPolicy = resourceUrlPolicy;
        return this;
    }
}
exports.BaseSanitizerBuilder = BaseSanitizerBuilder;
/**
 * This class allows modifications to the default sanitizer configuration.
 * It builds an instance of `HtmlSanitizer`.
 */
class HtmlSanitizerBuilder extends BaseSanitizerBuilder {
    build() {
        if (this.calledBuild) {
            throw new Error('this sanitizer has already called build');
        }
        this.calledBuild = true;
        return new html_sanitizer_js_1.HtmlSanitizerImpl(this.sanitizerTable, secrets_js_1.secretToken, 
        /* styleElementSanitizer= */ undefined, 
        /* styleAttributeSanitizer= */ undefined, this.resourceUrlPolicy);
    }
}
exports.HtmlSanitizerBuilder = HtmlSanitizerBuilder;
/**
 * This class allows modifications to the default sanitizer configuration.
 * It builds an instance of `CssSanitizer`.
 */
class CssSanitizerBuilder extends BaseSanitizerBuilder {
    constructor() {
        super(...arguments);
        this.animationsAllowed = false;
        this.transitionsAllowed = false;
        this.openShadow = false;
    }
    allowAnimations() {
        this.animationsAllowed = true;
        return this;
    }
    allowTransitions() {
        this.transitionsAllowed = true;
        return this;
    }
    /**
     * Sets the shadow DOM mode to 'open'.
     *
     * While this method is not formally restricted, it can potentially be used to
     * bypass the security guarantees of the CSS sanitizer. If you need open
     * shadow DOM, please contact ise-web-members@ to discuss your use case.
     */
    withOpenShadow() {
        this.openShadow = true;
        return this;
    }
    /**
     * Builds a CSS sanitizer.
     *
     * Note that this function always adds `style`, `id`, `name` and `class`
     * attributes to the allowlist as well as the `STYLE` element.
     */
    build() {
        this.extendSanitizerTableForCss();
        const propertyDiscarders = [];
        if (!this.animationsAllowed) {
            propertyDiscarders.push((property) => /^(animation|offset)(-|$)/.test(property));
        }
        if (!this.transitionsAllowed) {
            propertyDiscarders.push((property) => /^transition(-|$)/.test(property));
        }
        const styleElementSanitizer = (cssText) => (0, sanitizer_js_1.sanitizeStyleElement)(cssText, allowlists_js_1.CSS_PROPERTY_ALLOWLIST, allowlists_js_1.CSS_FUNCTION_ALLOWLIST, this.resourceUrlPolicy, this.animationsAllowed, propertyDiscarders);
        const styleAttributeSanitizer = (cssText) => (0, sanitizer_js_1.sanitizeStyleAttribute)(cssText, allowlists_js_1.CSS_PROPERTY_ALLOWLIST, allowlists_js_1.CSS_FUNCTION_ALLOWLIST, this.resourceUrlPolicy, propertyDiscarders);
        return new html_sanitizer_js_1.HtmlSanitizerImpl(this.sanitizerTable, secrets_js_1.secretToken, styleElementSanitizer, styleAttributeSanitizer, this.resourceUrlPolicy, this.openShadow);
    }
    extendSanitizerTableForCss() {
        const allowedElements = new Set(this.sanitizerTable.allowedElements);
        const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);
        const globalAttributePolicies = new Map(this.sanitizerTable.globalAttributePolicies);
        allowedElements.add('STYLE');
        globalAttributePolicies.set('style', {
            policyAction: sanitizer_table_js_1.AttributePolicyAction.KEEP_AND_SANITIZE_STYLE,
        });
        allowedGlobalAttributes.add('id');
        allowedGlobalAttributes.add('name');
        allowedGlobalAttributes.add('class');
        this.sanitizerTable = new sanitizer_table_js_1.SanitizerTable(allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, globalAttributePolicies, this.sanitizerTable.globallyAllowedAttributePrefixes);
    }
}
exports.CssSanitizerBuilder = CssSanitizerBuilder;
